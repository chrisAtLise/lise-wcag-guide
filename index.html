<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    <link rel="stylesheet" href="./style.css" />
    <script src="./assets/tailwindstyles.js"></script>
    <title>lise WCAG 2.2 Guide</title>
  </head>
  <body class="bg-darklise text-white">
    <div
      class="md:absolute top-40 md:top-20 w-2/5 md:w-1/5 h-8 flex flex-col items-center"
    >
      <img src="./assets/lise.svg" alt="Logo of lise GmbH" class="" />
    </div>
    <div
      id="app"
      class="container sm:max-w-lg md:max-w-3xl lg:max-w-4xl relative mx-auto mt-32 px-4 sm:px-8 md:px-16"
    >
      <header
        class="mx-auto my-8 text-white bg-teal-950 p-8 rounded-xl text-left flex flex-col md:flex-row"
      >
        <div class="sm:w-3/4">
          <h1 class="font-bold text-4xl text-center md:text-left">
            WCAG 2.2 Guide
          </h1>
          <p class="!text-sm leading-loose mt-4 md:pr-8">
            a hitchhikers guide to WCAG by the girls and boys working at lise.
            This document is based on
            <a
              class="underline"
              href="https://www.w3.org/TR/2024/REC-WCAG22-20241212/"
              >the WCAG from 12 December 2024</a
            >
          </p>
        </div>
        <img
          src="./assets/wcag.svg"
          class="w-32 my-4 mx-auto"
          alt="Logo of wcag 2.2 aaa"
        />
      </header>

      <!-- Filter Sidebar -->

      <aside
        class="transition z-50 ease-in-out transform filter w-full md:w-[300px] mx-auto my-4 text-xs rounded-md px-8 py-4 md:fixed top-0 right-2 shadow-lg shadow-emerald-800/50 bg-teal-950 opacity-95"
        :class="{'translate-x-[80%] h-18 overflow-hidden': asideClose}"
      >
        <div class="flex items-center">
          <button
            aria-label="collapse"
            class="text-lise rounded-sm w-10 h-10 cursor-pointer hover:bg-darklise -ml-4 hidden sm:block mr-8"
            @click="asideClose=!asideClose"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              enable-background="new 0 0 24 24"
              height="24px"
              viewBox="0 0 24 24"
              width="24px"
              fill="currentColor"
              class="transform ml-2"
              :class="{'rotate-180': !asideClose}"
            >
              <g><rect fill="none" height="24" width="24" /></g>
              <g>
                <g>
                  <polygon
                    points="17.59,18 19,16.59 14.42,12 19,7.41 17.59,6 11.59,12"
                  />
                  <polygon
                    points="11,18 12.41,16.59 7.83,12 12.41,7.41 11,6 5,12"
                  />
                </g>
              </g>
            </svg>
          </button>
          <h2 class="text-base font-bold sm:opacity-60 py-4">
            Filter the entries
          </h2>
        </div>

        <div class="flex py-4">
          <div class="w-1/4">
            <label class="font-bold">Conformance level</label>
          </div>
          <div class="w-3/4 flex justify-between pl-8">
            <label
              v-for="level in conformanceLevels"
              :key="level"
              class="p-1 flex flex-col items-center w-12 border border-transparent"
              :class="{' border-white rounded-md text-lise':selectedConformanceLevel===level}"
            >
              <input
                type="radio"
                v-model="selectedConformanceLevel"
                :value="level"
              />

              <span class="font-bold text-lg pt-2">{{level}}</span>
            </label>
          </div>
        </div>

        <!-- Tags List -->
        <label class="font-bold pb-4">Filter Perspective</label>
        <div class="flex flex wrap">
          <select
            class="bg-darklise p-2 rounded-md w-full mt-2 mb-4"
            v-model="selectedPerspective"
            id="perspective"
          >
            <option
              v-for="perspective in perspectives"
              :key="perspective.id"
              :value="perspective.name"
            >
              {{perspective.name}}
            </option>
          </select>
        </div>
        <span
          v-if="selectedPerspectiveDescription && selectedPerspectiveDescription.description"
          >{{selectedPerspectiveDescription.description}}
        </span>
        <label class="font-bold block pt-4">Do you use...</label>
        <div
          v-for="filter in filters"
          :key="filter.name"
          class="flex pt-2 checkbox-container"
        >
          <label class="w-3/4 cursor-pointer">{{filter.question}} </label>
          <button
            class="rounded-full w-[50px] bg-darklise p-1 inline-block h-6 relative cursor-pointer"
            :class="{'bg-lise':selectedTags.includes(filter.name),'bg-darklise':!selectedTags.includes(filter.name)}"
            @click="toggleTag(filter.name)"
          >
            <span
              class="toggle"
              :class="{'translate-x-[10px] bg-darklise':selectedTags.includes(filter.name),'-translate-x-[10px] bg-white':!selectedTags.includes(filter.name)}"
            ></span>
          </button>
          <span class="w-10 h-6 flex justify-end items-center"
            >{{selectedTags.includes(filter.name)?"Yes":"No"}}</span
          >

          <hr />
        </div>

        <label class="mt-5 block text-lg">
          Applicable entries:
          <span class="text-lise">{{ filteredContent.length }}</span>
        </label>
      </aside>

      <!-- Filtered Content -->
      <main v-for="entry in filteredContent" :key="entry.name">
        <div>
          <div class="relative">
            <component :is="`h${entry.level+1}`" class=""
              >{{ entry.name }}</component
            >
            <div
              v-if="entry.conformance"
              class="conformance"
              v-if="entry.conformance"
            >
              {{ entry.conformance }}
            </div>
            <div class="infobox">
              <div
                v-if="entry.understanding.length > 5"
                class="understanding"
                v-html="entry.understanding"
              ></div>
            </div>
          </div>
          <template v-for="tag in entry.tags" :key="tag"
            ><span class="tag" v-if="tag.length > 1">{{tag}}</span></template
          >
          <div v-html="entry.html"></div>
        </div>
      </main>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
      const { createApp, ref, computed, onMounted, watch } = Vue;

      createApp({
        setup() {
          const content = ref([]);
          const perspectives = ref([]);
          const filters = ref([]);
          onMounted(async () => {
            try {
              const response = await fetch("./data/wcag22_tag.json");
              content.value = await response.json();
              console.log(content.value);
              extractTags(); // Extract tags after loading content
              const responsePerspectives = await fetch(
                "./data/perspectives.json"
              );
              perspectives.value = await responsePerspectives.json();
              const responseFilters = await fetch("./data/filters.json");
              filters.value = await responseFilters.json();
              selectedTags.value = filters.value.map((item) => item.name);
            } catch (error) {
              console.error("Error loading JSON:", error);
            }
          });
          const asideClose = ref(false);
          const selectedTags = ref([]);
          const resetTags = () => {
            selectedTags.value = [];
          };
          const tags = ref([]);
          const selectedConformanceLevel = ref("AAA");
          const conformanceLevels = ["A", "AA", "AAA"];

          const selectedPerspective = ref("show all");
          const selectedPerspectiveDescription = computed(() => {
            if (!selectedPerspective.value) return null;
            // Use find instead of filter to get a single object
            return perspectives.value.find(
              (perspective) => perspective.name === selectedPerspective.value
            );
          });
          // Extract unique tags
          const extractTags = () => {
            const allTagsSet = new Set();
            content.value.forEach((entry) => {
              if (entry.tags && Array.isArray(entry.tags)) {
                entry.tags.forEach((tag) =>
                  tag.length > 1 ? allTagsSet.add(tag) : null
                );
              }
            });
            tags.value = Array.from(allTagsSet);
          };

          // Toggle tag selection
          const toggleTag = (tag) => {
            if (selectedTags.value.includes(tag)) {
              selectedTags.value = selectedTags.value.filter((t) => t !== tag);
            } else {
              selectedTags.value.push(tag);
            }
          };

          // Compute available tags dynamically
          const allTags = computed(() => tags.value);

          // Compute filtered content
          const filteredContent = computed(() => {
            return content.value
              .filter((entry) => {
                // Always show level 1 and 2 entries
                if (entry.level == 1) {
                  return true;
                }
                // Filter by conformance level
                if (selectedConformanceLevel.value === "A") {
                  return entry.conformance === "A";
                } else if (selectedConformanceLevel.value === "AA") {
                  return (
                    entry.conformance === "AA" || entry.conformance === "A"
                  );
                } else if (selectedConformanceLevel.value === "AAA") {
                  return ["AAA", "AA", "A"].includes(entry.conformance);
                }

                return true;
              })
              .filter((entry) => {
                // If no tags are selected, show all
                if (selectedTags.value.length === 0) return true;
                if (entry.level == 1) {
                  return true;
                }
                // Only show entries that match at least one selected tag
                return (
                  entry.tags &&
                  entry.tags.some((tag) => selectedTags.value.includes(tag))
                );
              })
              .filter((entry) => {
                if (entry.level == 1) {
                  return true;
                }
                if (selectedPerspective.value == "show all") return true;
                return (
                  entry.tags &&
                  entry.tags.some((tag) => selectedPerspective.value === tag)
                );
              });
          });

          watch(selectedConformanceLevel, (newValue) => {
            console.log("Filter changed to:", newValue);
          });

          return {
            content,
            filteredContent,
            selectedConformanceLevel,
            allTags,
            selectedTags,
            toggleTag,
            resetTags,
            asideClose,
            conformanceLevels,
            perspectives,
            selectedPerspective,
            selectedPerspectiveDescription,
            filters,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
